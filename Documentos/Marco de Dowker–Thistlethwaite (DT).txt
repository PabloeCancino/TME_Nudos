
## 1. Marco de Dowker–Thistlethwaite (DT): qué datos combinatorios codifican una proyección

### 1.1. Proyección, numeración y la involución (a)

Parten de una **proyección regular** de un nudo:

* Un nudo (K\subset S^3) se proyecta en (S^2) (o en el plano) con solo **puntos dobles transversales** (los cruces) y sin triple intersección.
* Si hay (n) cruces, la proyección tiene (2n) puntos donde la curva cruza esos vértices.

Se fija una orientación en el nudo y se hace lo siguiente:

1. Se escoge un punto de inicio en el diagrama.
2. Se recorre el nudo siguiendo la orientación y se numeran los puntos donde el nudo entra/sale de cada cruce con los números
   [
   1,2,3,\dots,2n
   ]
   en orden, a lo largo del recorrido.

Cada cruce es encontrado exactamente dos veces al recorrer el nudo; esas dos visitas llevan etiquetas (i) y (j) en ({1,\dots,2n}). DT encapsulan este emparejamiento con una aplicación

[
a:{1,\dots,2n}\to{1,\dots,2n},
]

con las propiedades:

* (a(a(i)) = i) (es una **involución**),
* (a(i)) siempre tiene paridad opuesta a la de (i) (si (i) es impar, (a(i)) es par, y viceversa).

La secuencia

[
S = (a_1,\dots,a_{2n}),\quad a_k = a(k),
]

es una codificación de cómo se emparejan los puntos del recorrido para formar cruces.

La notación de Dowker–Thistlethwaite que usamos en la práctica (`dt_notation`) es precisamente la parte “par” de esa secuencia:

[
\text{DT}(K) = [d_1,\dots,d_n],\quad
\text{donde } a(2i-1) = d_i.
]

Es decir, el cruce (i) está dado por las etiquetas ((2i-1, d_i)).
Eso es exactamente lo que conviertes en pares ((p_i,q_i)) en tu (\mathbb{Z}_{2n}).

---

### 1.2. Regla 1: evitar nudos compuestos y cruces nugatorios

No toda involución (a) sobre ({1,\dots,2n}) viene de un diagrama “bien comportado”. Una primera restricción clave es la **Regla 1**:

> No debe existir un intervalo propio ([i,j]\subset{1,\dots,2n}) tal que (a) lleve ([i,j]) en sí mismo.

Intuición:

* Si existe un intervalo ([i,j]) cerrado bajo (a), entonces hay un subdiagrama encerrado en un lazo:
  eso corresponde a:

  * un nudo **compuesto** (suma conexa), o
  * un cruce **nugatorio** (el típico lazo que se puede quitar con R1).

Imponiendo Regla 1, las secuencias que quedan corresponden a **proyecciones “reducidas” de nudos primos** (o casi).

Para tu teoría es importante porque te garantiza que, al trabajar con DT que cumplen esta regla, no estás codificando basura: estás realmente en el reino de “proyecciones buenas”.

---

### 1.3. Grafo 4–valente y realizabilidad

Dada una secuencia (S) (o la involución (a)), DT construyen un **grafo 4–valente** (G(S)):

* Los vértices son los cruces.
* Los “arcos” del nudo, entre etiquetas sucesivas (k \to k+1) (mod (2n)), y las cuerdas que emparejan (i \leftrightarrow a(i)), se combinan para dar un grafo embedded en un círculo.

La pregunta central:

> ¿Existe una inmersión de (G(S)) en (S^2) que respete el orden cíclico de las semiaristas alrededor de cada vértice?

Si **sí**, decimos que la secuencia (S) es **realizable** como proyección de un nudo en el plano.

El teorema clave de DT es que, bajo Regla 1:

* Si (S) es realizable, entonces **cualquier** realización es equivalente por un homeomorfismo de (S^2).
  Es decir, (S) determina una **clase única de proyección**.

Esto te permite pensar en la secuencia DT como una “coordenada” limpia de la proyección, no contaminada por decisiones de dibujo.

---

### 1.4. Orientación: función (f) e información “izquierda/derecha”

Hasta aquí, (S) sólo dice **dónde** están los cruces, no cómo el nudo “gira” en ellos. Para capturar la estructura alternante y la orientación geométrica, DT introducen una función

[
f:{1,\dots,2n}\to{\pm 1},
]

que codifica, en cada paso del recorrido, algo así como “paso a la izquierda/derecha” o “giro positivo/negativo” al cruzar por un vértice.

Junto con (f), definen funciones auxiliares (\phi_i) asociadas a los lazos ([i,a(i)]) que “encapsulan” zonas del diagrama. El detalle fino de estas funciones no lo necesitamos acá, pero la idea es:

* (\phi_i(k)) te dice si el tramo en torno a (k) está “dentro” o “fuera” de cierto lazo asociado al cruce (i).
* Con esas (\phi_i) y (f) se formula una **condición combinatoria** que distingue cuándo (S) viene de una proyección alternante “bien orientada”.

---

### 1.5. Regla 2: carácter alternante y orientación canónica

La **Regla 2** formal de DT es una condición explícita sobre ((S,f)) que es:

* necesaria y suficiente para que la proyección sea **alternante** (over/under se alternan al seguir cada componente),
* compatible con una orientación global del nudo.

Es decir, dado (S), no todas las posibles asignaciones de (f) son geométricamente realizables como nudos alternantes.

El siguiente paso crucial es:

> **Orientación canónica**:
> DT definen una función (f_{\text{can}}) construida inductivamente a partir de (S) y prueban que:
>
> * si (S) es realizable, entonces ((S,f_{\text{can}})) satisface Regla 2,
> * y la orientación geométrica del diagrama coincide con (f_{\text{can}}) (hasta equivalencias naturales).

Consecuencia:

* Para cada (S) realizable, hay una forma **canónica y puramente combinatoria** de asignar la información de orientación alternante.
* Esto es lo que luego se traduce en signos en el DT code (positivos/negativos) y en códigos como los que aparecen en Knot Atlas.

---

### 1.6. Resultado global de DT

Poniendo todo junto:

1. **Entrada**: secuencia (S) (o un DT code).
2. **Filtro 1 (Regla 1)**: descarta secuencias que necesariamente dan nudos compuestos o cruces nugatorios.
3. **Chequeo de realizabilidad**: decide si (S) viene de una inmersión plana.
4. **Construcción de (f_{\text{can}})**: a partir de (S).
5. **Filtro 2 (Regla 2)**: verifica que ((S,f_{\text{can}})) produce una proyección alternante válida.
6. **Salida**: una proyección de nudo alternante, bien definida hasta homeomorfismo de (S^2).

Esta es la base teórica “dura” sobre la que después se apoyan las tablas DT, Knot Atlas, KnotInfo, etc.

---

## 2. Diccionario hacia tu teoría modular racional

Ahora hacemos el puente: mostrar que los objetos de DT se corresponden naturalmente con los de tu marco modular.

### 2.1. De ({1,\dots,2n}) a (\mathbb{Z}_{2n})

En tu teoría modular racional:

* Trabajas en el círculo discreto
  [
  \mathcal{R}_{2n} = \mathbb{Z}/(2n)\mathbb{Z} = {0,1,\dots,2n-1}.
  ]
* Un **recorrido** corresponde a seguir la sucesión
  [
  0 \to 1 \to 2 \to \cdots \to 2n-1 \to 0.
  ]

Si tomas la numeración DT (1,\dots,2n) y aplicas (\bar k := k-1), obtienes un isomorfismo:

[
{1,\dots,2n} \cong \mathbb{Z}_{2n},
\qquad
k \longmapsto k-1.
]

La involución (a) de DT se transporta a una involución

[
\tilde a:\mathbb{Z}*{2n}\to\mathbb{Z}*{2n},\quad
\tilde a(\bar k) = a(k) - 1.
]

Es exactamente la misma información combinatoria, sólo con numeración 0–based.

---

### 2.2. De DT code ([d_1,\dots,d_n]) a pares modulares

Cada cruce (i) en DT está dado por las etiquetas ((2i-1, d_i)). En tu marco modular, lo traducimos como:

[
(p_i, q_i) := (2i-1-1,\ d_i-1) \in \mathbb{Z}_{2n}^2.
]

Esta es la **configuración racional básica** (sin aún decidir cuál es “over”/“under” ni el signo).

Conversión explícita:

```python
config = []
for i, a in enumerate(dt, start=1):
    p = (2*i - 1 - 1) % (2*n)
    q = (a - 1) % (2*n)
    config.append((p, q))
```

Opcionalmente, puedes aplicar un **shift global** (k \mapsto k+c) módulo (2n) a todos los índices (corresponde a mover el punto de inicio del recorrido) y reordenar los cruces. Eso no cambia el nudo, sólo la presentación.

En suma: la información de (S) o del DT code **ya está** en tus pares ((p_i,q_i)).

---

### 2.3. Proyección DT vs proyección modular

En DT:

* Una secuencia (S) (o DT) realizable describe una **proyección** de nudo: grafo 4–valente embebido en (S^2).

En tu teoría:

* La lista de pares ((p_i,q_i)) sobre (\mathbb{Z}_{2n}), satisfaciendo analogías de Regla 1 (no intervalos cerrados) y ciertas condiciones, describe la **estructura de proyección modular**: qué puntos del recorrido discreto se emparejan como cruces.

Entonces:

> **Proyección DT ≈ Proyección modular:**
> Una secuencia realizable (S) en el sentido DT corresponde 1–a–1 a una configuración de pares ((p_i,q_i)) en tu círculo modular que es realizable como nudo en el plano.

Esta identificación es el primer nivel del puente: tu “modelo racional” no está inventando una estructura rara, sino reescribiendo el aparato de DT en (\mathbb{Z}_{2n}).

---

## 3. Orientación, signos y tu configuración racional enriquecida

Lo que DT aportan, además de la proyección, es la **orientación canónica alternante** y el control de **signos** de cruce.

Tú, por tu parte, para trabajar con invariantes racionales, necesitas:

* decidir en cada par ((p_i,q_i)) quién es “over” y quién “under”,
* fijar el signo (\varepsilon_i \in {+1,-1}) de cada cruce.

### 3.1. De (f_{\text{can}}) y signos DT a ((\text{over}_i,\text{under}_i,\varepsilon_i))

En DT extendidos (como los de KnotInfo/KnotAtlas), cada entrada del DT puede llevar signo:

* ([d_1,\dots,d_n]) con (d_i \in {\pm 2,\pm 4,\dots}).

El **signo** de (d_i) combina la orientación y si en la etiqueta par estás pasando por encima o por debajo del cruce.

Sin fijar aún la convención fina, la idea general para ti es:

1. La parte **posicional** de (d_i) (el valor absoluto) te dice dónde está la segunda entrada del cruce (eso ya lo usamos).
2. El signo de (d_i), junto con la orientación canónica (f_{\text{can}}), te dice:

   * si el paso impar es over o under,
   * si el cruce es positivo o negativo.

En tu notación:

* defines para cada cruce (i) un triple
  [
  (o_i, u_i, \varepsilon_i) \in \mathbb{Z}*{2n}\times\mathbb{Z}*{2n}\times{\pm 1},
  ]
  donde (o_i) es la posición “over”, (u_i) la posición “under”, y (\varepsilon_i) el signo del cruce.

La receta esquemática es:

* Tienes ((p_i,q_i)) = posiciones en el recorrido.

* Usas el signo de (d_i) y la regla de orientación de DT para decidir una de estas:

  * si (d_i>0): over en la entrada par, under en la impar (por ejemplo),
  * si (d_i<0): over en la impar, under en la par,

  o la convención que elijas, pero **consistente** con el artículo de DT y con KAtlas.

* El signo (\varepsilon_i) del cruce se determina por la orientación local (regla habitual de cruce positivo/negativo).

Resultado: del DT con signos y de (f_{\text{can}}) extraes una **configuración racional enriquecida**:

[
K_{\text{rat}} = {(o_i,u_i,\varepsilon_i)}_{i=1}^n,
]

que es exactamente el tipo de objeto que estás usando en tu teoría (matrices firmadas, tensor (K), etc.).

---

### 3.2. Smoothing de Seifert y tu (\tau) modular

DT, al estudiar proyecciones alternantes, implícitamente controlan también el **alisado de Seifert** (aunque ellos no lo formulen en estos términos). En tu construcción del género modular, necesitas:

* los **arcos** (A_j) entre posiciones under ordenadas,
* los extremos (E = {(j,\pm)}),
* la involución (\beta) que recorre el arco,
* la involución (\tau) que aplica el smoothing en cada under,
* la permutación (\sigma = \tau\circ\beta), cuyas órbitas dan los círculos de Seifert modulares.

El paso de DT a tu (\tau) se puede describir conceptualmente así:

1. A partir de (S) y (f_{\text{can}}), conoces para cada posición del recorrido:

   * qué cruce estás visitando,
   * cómo está orientado el cruce,
   * qué semiarco del grafo 4–valente estás transitando.

2. El smoothing de Seifert, en cada cruce, une dos semiarcos de acuerdo con la orientación:

   * cruces con (\varepsilon_i = +1) se suavizan de una manera,
   * cruces con (\varepsilon_i = -1) se suavizan de la opuesta.

3. Cada semiarco se traduce, en tu modelo modular, en un extremo de arco ((j,\pm)) situado en una posición under. Saber qué semiarcos se conectan al suavizar es exactamente saber cómo emparejar extremos en (\tau).

En la práctica:

* tu **(\beta)** se calcula sin DT: es puramente modular (une extremos del mismo arco).
* tu **(\tau)** debe reconstruirse usando la información DT + orientación, no sólo “emparejando los dos extremos que comparten la misma posición”.

El artículo de DT te dice que, para proyecciones alternantes, hay una forma canónica de fijar esa información; tú puedes apoyarte en eso para definir una **(\tau_{\text{DT}})** coherente con la geométrica, y de ahí obtener un (\sigma) cuyos ciclos reproduzcan fielmente la superficie de Seifert.

---

## 4. El puente concreto: cómo integrar DT en la teoría modular racional

Podemos ahora resumir el “pipeline” que realiza el puente:

### 4.1. Nivel 1: Proyección

**Entrada:** `dt_notation` sin signos (o con signos, ignorándolos al principio).

1. Parseas `dt_notation = [d_1,\dots,d_n]`.
2. Construyes pares modulares
   [
   (p_i,q_i) = (2i-1-1,\ \lvert d_i\rvert -1)\in\mathbb{Z}_{2n}^2.
   ]
3. Obtienes la **proyección modular**: una lista de pares ((p_i,q_i)) que refleja la misma involución (a) que DT.

**Teorema–puente (esquema):**
Si la secuencia DT (S) es realizable en el sentido de DT, entonces la lista ((p_i,q_i)) es realizable en tu marco modular como configuración racional de alguna proyección de nudo.

---

### 4.2. Nivel 2: Diagrama orientado y configuración racional enriquecida

**Entrada:** `dt_notation` con signos, más la construcción de (f_{\text{can}}) de DT.

1. Interpretas el signo de cada (d_i) y la orientación canónica para decidir:

   * cuál de (p_i,q_i) es over y cuál under,
   * el signo (\varepsilon_i) del cruce.

2. Construyes:

   [
   K_{\text{rat}} = {(o_i,u_i,\varepsilon_i)}*{i=1}^n
   ]
   en (\mathbb{Z}*{2n}).

3. Esto ya es un objeto de tu teoría: puedes construir:

   * matrices de incidencia, cruces, matrices firmadas (S(K)),
   * el tensor (K(k,\ell,a)),
   * los arcos (A_j), extremos (E), etc.

---

### 4.3. Nivel 3: Género modular y comparación con `three_genus`

Con (K_{\text{rat}}) tienes todo lo necesario para definir:

* los arcos modulares a partir de las posiciones under,
* las involuciones (\beta,\tau),
* la permutación (\sigma = \tau\circ\beta),
* el número de ciclos (s_{\text{mod}}(K)),
* el género modular
  [
  g_{\text{mod}}(K) = \frac{c(K) - s_{\text{mod}}(K) + 1}{2}.
  ]

El programa natural (y muy potente) es:

> **Conjetura / teorema a probar:**
> Para todo nudo clásico (K), si construimos (K_{\text{rat}}) a partir de su DT code según el procedimiento anterior, entonces
> [
> g_{\text{mod}}(K) = g_{\text{Seifert}}(K) = \text{`three_genus` en la BD}.
> ]

Validar esto en rango bajo (por ejemplo, con todas las entradas de KnotInfo) da una evidencia fuerte de que tu **género modular** está correctamente alineado con el género clásico, y que la traducción DT → modular es consistente.

---

### 4.4. Nivel 4: más allá del género

Una vez que el puente está establecido, puedes reinterpretar:

* los **tests de realizabilidad** de DT (Regla 1, Rule 2),
* la **orientación canónica**,
* y la propia estructura de las proyecciones,

en términos puramente modulares:

* condiciones algebraicas sobre los pares ((o_i,u_i,\varepsilon_i)) en (\mathbb{Z}_{2n}),
* ecuaciones/relaciones entre las matrices que construyes,
* propiedades del tensor (K).

Ahí es donde tu teoría puede empezar a producir **nuevos invariantes racionales** (por ejemplo, versiones modulares del polinomio de Jones, de la firma, de invariantes de quiralidad) que se lean directamente de tu notación sin necesidad de reconstruir el diagrama plano.

---

Si quieres, el siguiente paso podría ser muy concreto:
tomar 1–2 ejemplos de nudos donde la `dt_notation` tiene signos, reconstruir a mano (con tus reglas) el ((o_i,u_i,\varepsilon_i)), y escribir ya el algoritmo 100 % explícito DT → `configuracion_Racional_enriquecida` que luego podamos automatizar en Python.





# Resumen del artículo de Dowker–Thistlethwaite
Dowker, C. H. and Thistlethwaite, M. B. "Classification of Knot Projections." Topol. Appl. 16, 19-31, 1983.

1. **Fijar el objeto combinatorio básico**

   * Parten de una proyección regular (L) de un nudo con (n) cruces.
   * Numeran los (2n) puntos de cruce sobre el nudo (K) y definen una **involución paridad-reversora**
     [
     a:{1,\dots,2n}\to{1,\dots,2n},\quad a(a(i))=i,
     ]
     donde (a(i)) es el otro punto de cruce con la misma proyección. La secuencia (S=(a_1,\dots,a_{2n})) (o solo sus entradas impares) es el código tipo DT. 

2. **“Rule 1”: filtrar lo que no puede venir de un nudo primo**

   * Prohíben intervalos propios ([i,j]\subset{1,\dots,2n}) que sean estables bajo la involución (a); eso correspondería a nudos compuestos o a reducciones triviales de cruces.
   * Este filtro deja solo secuencias candidatas para **proyecciones de nudos primos**.

3. **Realizabilidad: de la secuencia al grafo 4-valente**

   * Construyen un grafo 4-valente (G) pegando (0\sim 2n) y (i\sim a_i).
   * Demuestran (Lema 1 + Teorema 1) que si existe una inmersión plana de (G) que respete el orden cíclico en cada vértice, entonces cualquier dos realizaciones son equivalentes por un homeomorfismo de (S^2).
   * En otras palabras, **una secuencia realizable define una clase única de proyección**.

4. **Orientación canónica y “Rule 2”**

   * Introducen una función (f:{1,\dots,2n}\to{\pm1}) que codifica la orientación de los cruces (cruza de derecha a izquierda o viceversa) y una familia de funciones (\phi_i) que detectan “dentro/fuera” respecto a los lazos ([i,a_i]).
   * Formulan la **Rule 2**: una condición explícita en términos de (\phi_i) y (f) que es **necesaria y suficiente** para que ((S,f)) sea realizable como diagrama alternante.
   * Definen un **“canonical orientation”**: una manera inductiva de fijar (f) a partir solo de (S); luego prueban que:

     * (S) es realizable ⇔ ((S,f_{\text{can}})) cumple Rule 2,
     * y, si lo es, (f_{\text{can}}) coincide con la orientación geométrica del diagrama.

5. **Algoritmo final**

   * Terminan dando un **algoritmo explícito** (tipo pseudocódigo) para:

     * construir (f) canónico,
     * ir chequeando Rule 2,
     * y decidir si una secuencia (S) tabulada es o no proyección de un nudo.
   * Esto es justo la base teórica de lo que luego se usa en KAtlas y en las tablas modernas.

---

Con esto en mente: lo que hemos hecho al tomar `dt_notation` y mapearla a tu **configuración racional en (\mathbb{Z}_{2n})** es coherente con la estructura de (S) como *involución paridad-reversora* que ellos usan.

Lo que **todavía no hemos explotado** (y que el artículo deja muy bien formulado) son:

* la orientación canónica (f),
* y las condiciones tipo Rule 2,

para decidir, dentro de tu marco modular, **qué pares deben ser over/under y cómo se codifica fielmente la orientación**. Ese es el puente fino entre la teoría clásica DT y tu teoría modular racional.
