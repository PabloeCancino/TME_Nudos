/-- El gap es invariante bajo reflexión -/theorem gap_mirror (p : OrderedPair n) :    p.mirror.gap = p.gap := by  simp only [gap, mirror]  -- (-p.snd - (-p.fst)).val - 1 = (p.snd - p.fst).val - 1  congr 1  simp [sub_neg_eq_add, add_comm]/-- Encompasses is preserved under simultaneous mirror -/theorem encompasses_mirror (p : OrderedPair n) (x : ZMod (2 * n)) :    p.mirror.encompasses (-x) ↔ p.encompasses x := by  simp only [encompasses, mirror]  constructor <;> intro h  · simp at h    sorry  -- Requires ZMod arithmetic for negation  · simp    sorry  -- Requires ZMod arithmetic for negation/-- Interlacing is preserved under simultaneous mirror -/theorem isInterlaced_mirror (p q : OrderedPair n) :    p.mirror.isInterlaced q.mirror ↔ p.isInterlaced q := by  simp only [isInterlaced, mirror]  constructor <;> intro h  · cases h with    | inl h => left               exact ⟨(encompasses_mirror p q.fst).mp h.1,                      mt (encompasses_mirror p q.snd).mpr h.2⟩    | inr h => right               exact ⟨mt (encompasses_mirror p q.fst).mpr h.1,                      (encompasses_mirror p q.snd).mp h.2⟩  · cases h with    | inl h => left               exact ⟨(encompasses_mirror p q.fst).mpr h.1,                      mt (encompasses_mirror p q.snd).mp h.2⟩    | inr h => right               exact ⟨mt (encompasses_mirror p q.fst).mp h.1,                      (encompasses_mirror p q.snd).mpr h.2⟩
