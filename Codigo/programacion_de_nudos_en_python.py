# -*- coding: utf-8 -*-
"""Programacion de nudos en python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_M93DoAgTzch0OjzkKRMhCEN2Oy3mX7L
"""

import numpy as np
import matplotlib.pyplot as plt
import networkx as nx

def modular_difference(a, b, modulo):
    return (b - a) % modulo

def remove_consecutive_pairs(N, modulo):
    to_remove = []
    for i in range(N.shape[1]):
        if modular_difference(N[0][i], N[1][i], modulo) == 1 or modular_difference(N[1][i], N[0][i], modulo) == 1:
            to_remove.append(i)
    if to_remove:
        N = np.delete(N, to_remove, axis=1)
    return N

def reidemeister_type3(N):
    """
    Detección y eliminación simplificada del Movimiento 3 de Reidemeister.
    Requiere encontrar tripletas con relaciones cruzadas.
    """
    to_remove = []
    for i in range(N.shape[1] - 2):
        a, b, c = N[:, i], N[:, i+1], N[:, i+2]
        # Condición de cruce triple básico
        if len(set(a.tolist() + b.tolist() + c.tolist())) == 6:
            to_remove.extend([i, i+1, i+2])
            break
    if to_remove:
        N = np.delete(N, to_remove, axis=1)
    return N

def renombrar_matriz(N):
    if N.size == 0:
        return np.array([[0], [0]])
    unique_numbers = sorted(np.unique(N))
    mapping = {num: i + 1 for i, num in enumerate(unique_numbers)}
    return np.vectorize(mapping.get)(N)

def dibujar_nudo(N, titulo='Nudo'):
    """
    Visualiza el nudo como grafo entre pares ordenados.
    """
    G = nx.Graph()
    for i in range(N.shape[1]):
        a, b = N[0, i], N[1, i]
        G.add_edge(a, b)

    pos = nx.spring_layout(G, seed=42)
    plt.figure(figsize=(6, 6))
    nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=600, font_weight='bold')
    plt.title(titulo)
    plt.axis('off')
    plt.show()

def reidemeister_modular_simplificado(N):
    N = np.array(N)
    modulo = max(N.flatten())
    changes = True

    dibujar_nudo(N, 'Nudo original')

    while changes:
        changes = False
        for i in range(len(N[0])):
            if modular_difference(N[0][i], N[0][(i + 1) % len(N[0])], modulo) == 1:
                left = (i - 1) % len(N[0])
                right = (i + 2) % len(N[0])
                indices_to_remove = sorted({i, (i + 1) % len(N[0]), left, right})
                N = np.delete(N, indices_to_remove, axis=1)
                changes = True
                break

        N = remove_consecutive_pairs(N, modulo)
        N = reidemeister_type3(N)

    N = renombrar_matriz(N)
    dibujar_nudo(N, 'Nudo simplificado')
    return N

# Ejemplo: nudo 7 pares (puedes aumentar la cantidad)
N = [
    [1, 2, 14, 4, 12, 6, 8],
    [10, 9, 3, 7, 5, 13, 11]
]

N_simplificado = reidemeister_modular_simplificado(N)
print("Matriz simplificada:")
print(N_simplificado)

# Versión sin gráficos, con pasos explicados
import numpy as np

def modular_difference(a, b, modulo):
    return (b - a) % modulo

def remove_consecutive_pairs(N, modulo):
    to_remove = []
    for i in range(N.shape[1]):
        if modular_difference(N[0][i], N[1][i], modulo) == 1 or modular_difference(N[1][i], N[0][i], modulo) == 1:
            to_remove.append(i)
    if to_remove:
        print(f"Aplicando Movimiento 2 (pares con diferencia 1 entre niveles): eliminando columnas {to_remove}")
        N = np.delete(N, to_remove, axis=1)
        print("Matriz tras Movimiento 2:")
        print(N)
    return N

def reidemeister_type3(N):
    to_remove = []
    for i in range(N.shape[1] - 2):
        a, b, c = N[:, i], N[:, i+1], N[:, i+2]
        if len(set(a.tolist() + b.tolist() + c.tolist())) == 6:
            to_remove.extend([i, i+1, i+2])
            break
    if to_remove:
        print(f"Aplicando Movimiento 3 (tripleta sin cruce común): eliminando columnas {to_remove}")
        N = np.delete(N, to_remove, axis=1)
        print("Matriz tras Movimiento 3:")
        print(N)
    return N

def renombrar_matriz(N):
    if N.size == 0 or N.shape[1] == 0:
        return np.array([[0], [0]])
    unique_numbers = sorted(np.unique(N))
    mapping = {num: i + 1 for i, num in enumerate(unique_numbers)}
    return np.vectorize(mapping.get)(N)

def reidemeister_modular_simplificado(N):
    N = np.array(N)
    modulo = max(N.flatten())
    print("Matriz original:")
    print(N)

    changes = True
    step = 1

    while changes:
        changes = False
        for i in range(len(N[0])):
            if modular_difference(N[0][i], N[0][(i + 1) % len(N[0])], modulo) == 1:
                left = (i - 1) % len(N[0])
                right = (i + 2) % len(N[0])
                indices_to_remove = sorted({i, (i + 1) % len(N[0]), left, right})
                print(f"\nPaso {step}: Aplicando Movimiento 1 (lazada) - eliminando columnas {indices_to_remove}")
                N = np.delete(N, indices_to_remove, axis=1)
                print("Matriz tras Movimiento 1:")
                print(N)
                changes = True
                step += 1
                break

        before = N.copy()
        N = remove_consecutive_pairs(N, modulo)
        if not np.array_equal(N, before):
            changes = True
            step += 1

        before = N.copy()
        N = reidemeister_type3(N)
        if not np.array_equal(N, before):
            changes = True
            step += 1

    N = renombrar_matriz(N)
    print("\nMatriz final simplificada:")
    print(N)
    return N

# Ejemplo de uso
N = [
    [1, 5, 3],
    [4, 2, 6]
]

N_simplificado = reidemeister_modular_simplificado(N)